import io
import string

# Comments are defined like this
# Each file is a 'module'
# A module is a series of declarations
# Either class, function or variable

double a 
# Only floating-point type available since VM stack slots are
# 64 bits anyways, so floats will be a waste of space.
# The only place where there could be memory savings are heap-allocated arrays,
# but those aren't really worth the extra complexity.
# Thus all variable types will be made to utilize the full 64 bits.

int x # 64 bit signed int

uint y # 64 bit unsigned int

string s # Heap allocated strings

bool b # Boolean

void main():
	
	# Here we have a standard, C like syntax
	b = !(3 > 6)
	
	print('How old are you?')

	s = readln() # This function is from the 'io' module
	
	# Errors are heap-allocated objects.
	# They are the standard way in which functions tell you about errors.
	# Any function that can error out will take an error argument.
	# Usually, this is the last argument.
	# If a function can throw an error, it should be checked first
	# before doing anything with its return value.
	# If a function errorrs out, its return value should not be used.

	Error e # Since we discourage null pointers, most objects are automatically initialized.
	# ints should be used only if negative values are explicitly required
	# In all other cases use uint
	uint age = toUInt(s, 
						e)  # function from the 'string' module
	# Statements can be split across lines, as long as the last token on each line
	# except the last cannot end a statement. Automatic semicolon insertion works like in Go.
	
	b = 3 > 6; b = !b # Explicit semicolons are still supported.

	# Errors have 2 properties
	# 1) Code
	if e.code == 0:
		# Code zero means that everything went alright
		# Everything else is an error, each code representing one possible error
		# Now that we know nothing went wrong, we can safely utilize the return value
		if age >= 18:
			print('You can drive.')
		else:
			print('You cannot drive.')
		end

	# The user entered a float
	elif e.code == 1:
		print('Please make sure your age is a whole number')

	# The user entered a random string
	else:
		print('Please input a valid number')
	end
		
	# 2) message
	print(e.msg) # String describing the problem

	# While loops function as expected
	#
	uint i = 0
	while i < 10:
		print(i += 1)
	end

	# Arrays are heap allocated
	array<int> arr = [ 3, 6, 
							9, 5 ]
	# They can be initialized like so
	array<string> names = [<
							string, # Member type
							8, 		# Initial size
							'John' 	# Default member value
							>]

	# Their size can grow at runtime
	arr.append(4)

	# Members can be accessed like so
	print(arr[2]) # 9
	
	# Python-like for(each) loops
	for member in names:
		print(member)
	end

	# Array initializers are standalone expressions, which means	
	# They can be used on their own and passed around like values
	for n in [<bool, 12, false>]:
		print(n)
	end
	# Prints 'false' 12 times

	# Builtin hashtables
	# Key must be an object type
	table<string, uint> salaries
	salaries['John Smith'] = 30000

	if salaries.has('John Smith'):
		uint salary = salaries['John Smith']
	end
	
	# Instances can be created like this
	Vector a = Vector(1,2)

	# Member access functions as you would expect
	print(a.Magnitude())

end


class Vector:
		
	double a
	double b
	
	Vector(double a, double b):
		this.a = a
		this.b = b
	end
	
	double Magnitude():
		return sqrt(a*a+b*b)
	end
	
end
